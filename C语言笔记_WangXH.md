
<h1 style="text-align:center">C 语言笔记</h1>

--------------------------------------------------------------------------------
tips:

--------------------------------------------------------------------------------

<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=3 orderedList=false} -->

<!-- code_chunk_output -->

- [1. 基础语法](#-1-基础语法-)
  - [1.1. 关键词](#-11-关键词-)
  - [1.2. 标识符](#-12-标识符-)
  - [1.3. 语句结构](#-13-语句结构-)
  - [1.4. 数据类型](#-14-数据类型-)
    - [1.4.1. 基本类型](#-141-基本类型-)
    - [1.4.2. void](#-142-void-)
    - [1.4.3. 枚举](#-143-枚举-)
    - [1.4.4. 结构体](#-144-结构体-)
    - [1.4.5. 共用体](#-145-共用体-)
    - [1.4.6. 数组](#-146-数组-)
    - [1.4.7. 指针](#-147-指针-)
    - [1.4.8. 自定义数据类型](#-148-自定义数据类型-)
    - [1.4.9. 强制类型转换](#-149-强制类型转换-)
    - [1.4.10. 数据类型的选用](#-1410-数据类型的选用-)
  - [1.5. 变量与值](#-15-变量与值-)
    - [1.5.1. 变量](#-151-变量-)
    - [1.5.2. 特殊变量](#-152-特殊变量-)
    - [1.5.3. 数值常量](#-153-数值常量-)
    - [1.5.4. 字符串常量](#-154-字符串常量-)
    - [1.5.5. const 变量](#-155-const-变量-)
  - [1.6. 运算符](#-16-运算符-)
    - [1.6.1. 基本运算符](#-161-基本运算符-)
    - [1.6.2. 特殊运算符](#-162-特殊运算符-)
    - [1.6.3. 运算符优先级](#-163-运算符优先级-)
    - [1.6.4. 一些巧妙的运算](#-164-一些巧妙的运算-)
  - [1.7. 程序控制](#-17-程序控制-)
    - [1.7.1. 条件控制](#-171-条件控制-)
    - [1.7.2. 循环控制](#-172-循环控制-)
    - [1.7.3. goto](#-173-goto-)
  - [1.8. 函数](#-18-函数-)
    - [1.8.1. 声明](#-181-声明-)
    - [1.8.2. 定义](#-182-定义-)
    - [1.8.3. 调用](#-183-调用-)
    - [1.8.4. 主函数](#-184-主函数-)
    - [1.8.5. 特殊函数](#-185-特殊函数-)
  - [1.9. 作用域与生命周期](#-19-作用域与生命周期-)
  - [1.10. 内存管理](#-110-内存管理-)
    - [1.10.1. 数据存放](#-1101-数据存放-)
    - [1.10.2. 动态内存分配](#-1102-动态内存分配-)
    - [1.10.3. 数据对齐](#-1103-数据对齐-)
  - [1.11. 预处理](#-111-预处理-)
    - [1.11.1. 预处理命令](#-1111-预处理命令-)
    - [1.11.2. 预定义宏](#-1112-预定义宏-)
    - [1.11.3. 头文件](#-1113-头文件-)
  - [1.12. 输入/输出](#-112-输入输出-)
    - [1.12.1. 标准输入/输出](#-1121-标准输入输出-)
    - [1.12.2. 标准错误](#-1122-标准错误-)
    - [1.12.3. 文件访问](#-1123-文件访问-)
- [2. 标准库](#-2-标准库-)
  - [2.1. <assert.h>](#-21-asserth-)
  - [2.2. <ctype.h>](#-22-ctypeh-)
  - [2.3. <errno.h>](#-23-errnoh-)
  - [2.4. <float.h>](#-24-floath-)
  - [2.5. <iso646.h>](#-25-iso646h-)
  - [2.6. <limits.h>](#-26-limitsh-)
  - [2.7. <locale.h>](#-27-localeh-)
  - [2.8. <malloc.h>](#-28-malloch-)
  - [2.9. <math.h>](#-29-mathh-)
  - [2.10. <setjmp.h>](#-210-setjmph-)
  - [2.11. <signal.h>](#-211-signalh-)
  - [2.12. <stdarg.h>](#-212-stdargh-)
  - [2.13. <stddef.h>](#-213-stddefh-)
  - [2.14. <stdint.h>](#-214-stdinth-)
  - [2.15. <stdio.h>](#-215-stdioh-)
  - [2.16. <stdlib.h>](#-216-stdlibh-)
  - [2.17. <string.h>](#-217-stringh-)
  - [2.18. <time.h>](#-218-timeh-)
  - [2.19. <wchar.h>](#-219-wcharh-)
  - [2.20. <wctype.h>](#-220-wctypeh-)

<!-- /code_chunk_output -->

--------------------------------------------------------------------------------
# 1. 基础语法
* 第一个例程
    ```c++
    #include <stdio.h>

    int main() {
        printf("Hello, World! \n");
        return 0;
    }
    ```

## 1.1. 关键词
* 所有关键词
    ```c++
    auto
    break
    case, char, const, continue
    default, do, double,
    else, enum, extern
    float, for,
    goto
    if, int
    long
    register, return
    short, signed, sizeof, static, struct, switch
    typedef
    union, unsigned
    void, volatile,
    while
    ```
* 关键词分类
    |     类别     | 关键词                                                                                                                        |
    | :----------: | :---------------------------------------------------------------------------------------------------------------------------- |
    | 基本数据类型 | `void` <br/>`char`, `int` (`short`, `long`), `signed`/`unsigned` <br/>`float`, `double`                                       |
    | 数据类型定义 | `enum`, `struct`, `union` <br/> `typedef`                                                                                     |
    | 数据存储类型 | `static`, `extern`, `volatile`, `const`,`auto`, `register`                                                                   |
    |    运算符    | `sizeof`                                                                                                                      |
    |   程序控制   | `if...else...`, `switch...case...break...default...` <br/>`for...`, `while...`, `do...while` <br/>`break`, `continue`, `goto` |
    |     函数     | `return`                                                                                                                      |
    |   编译相关   | `inline`, `restrict`                                                                                                          |
* C99 新增关键字: `_Bool` `_Complex` `_Imaginary` `inline` `restrict`
* C11 新增关键字: `_Alignas` `_Alignof` `_Atomic` `_Generic` `_Noreturn` `_Static_assert` `_Thread_local`

## 1.2. 标识符
* 必须以字母或下划线 (`_`) 开头, 由字母、数字和下划线 (`_`) 组成
* 不能是关键词
* 区分大小写

## 1.3. 语句结构
* 语句
    * 一条语句以 `;` 结尾
    * 一条语句可以跨行
        * 显式跨行: 行尾使用反斜杠 `\`
        * 隐式跨行: `[]`, `{}` 或 `()` 中的多行语句, 不需要使用反斜杠 `\`
    * 一行中可以包含多条语句
* 代码块
    * `{}` 包裹的代码
* 空格
    * 包含: 空白符、制表符、换行符
    * 会被编译器忽略
* 注释
    * 单行注释: 以 `//` 开头
    * 多行注释: `/*` 和 `*/` 之间的单行或多行文字

## 1.4. 数据类型

### 1.4.1. 基本类型

| 数据类型      |     内存占用 (bytes)     | 数值范围                                                                                 |
| :------------ | :----------------------: | :--------------------------------------------------------------------------------------- |
| `char`        |            2             | `[signed] char`: -128 ~ 127 <br/>`unsigned char`: 0 ~ 255                                |
| `short [int]` | 与硬件平台相关, 一般为 2 | `[signed] short`: -32,768 ~ 32,767 <br/> `unsigned short`: 0 ~ 65,535                    |
| `int`         | 与硬件平台相关, 一般为 4 | `[signed] int`: -2,147,483,648 ~ 2,147,483,647 <br/> `unsigned int`: 0 ~ 4,294,967,295   |
| `long [int]`  | 与硬件平台相关, 一般为 4 | `[signed] long`: -2,147,483,648 ~ 2,147,483,647 <br/> `unsigned long`: 0 ~ 4,294,967,295 |
| `long long`   | 与硬件平台相关, 一般为 8 | `[signed] long long`: -2^63 ~ 2^63-1 <br/> `unsigned long long`: 0 ~ 2^64-1              |
| `float`       | 4 (一般为 IEEE754 标准)  | ± 1.2E-38 ~ ± 3.4E+38                                                                    |
| `double`      | 8 (一般为 IEEE754 标准)  | ± 2.3E-308 ~ ± 1.7E+308                                                                  |
| `long double` | 16 (一般为 IEEE754 标准) | -                                                                                        |

### 1.4.2. void
* 用于指定指针、函数返回值、函数参数的数据类型
    * `void * 指针` 表示指针可以被转换为任意类型
    * `void` 用于函数表示不需要返回值或参数

### 1.4.3. 枚举
* 在C 语言中, 枚举类型是被当做 `int` 或者 `unsigned int` 类型来处理的, 所以按照 C 语言规范是没有办法遍历枚举类型的
* 声明
    ```c++
    enum 枚举名 {枚举元素_1【= 特定值】, 枚举元素_2, ...};
    enum 枚举名 {枚举元素_1, ..., 枚举元素_k 【= 特定值】, ... };
    ```
    * 可为任意一个枚举元素赋特定值, 其后的值依次加 1
    * 枚举元素的默认值从 0 开始
* 定义
    ```c++
    enum 枚举名 枚举变量;
    // 仅定义一批变量时
    enum 枚举名 {枚举元素_1, 枚举元素_2, ...} 枚举变量;
    enum {枚举元素_1, 枚举元素_2, ...} 枚举变量;
    ```
* 常用做法
    ```c++
    // 声明时用 typedef 设置别名
    typedef enum {枚举元素_1, 枚举元素_2, ...} 枚举类型别名;
    // 定义时直接使用别名
    枚举类型别名 枚举变量;
    ```

### 1.4.4. 结构体
* 声明
    ```c++
    struct 结构体名称 {
        数据类型 成员_1 【: 位数】;
        数据类型 成员_2 【: 位数】;
        ...
    };
    ```
* 定义变量
    ```c++
    struct 结构体名称 结构体变量;       // 定义时不初始化
    // 或
    struct 结构体名称 结构体变量 = {    // 定义时初始化
        成员_1 的值,
        成员_2 的值,
        ...
    };
    // 仅定义一批变量时, 可使用匿名结构体
    struct {
        数据类型 成员_1;
        数据类型 成员_2;
        ...
    } 结构体变量【= 初始化值】; // 可初始化, 也可不初始化
    ```
* 访问成员
    ```c++
    结构体变量.成员名称     // . 方式
    结构体指针 -> 成员名称  // -> 方式
    ```
* 常用做法
    ```c++
    // 声明时用 typedef 设置别名
    typedef struct {
        数据类型 成员_1;
        数据类型 成员_2;
        ...
    } 结构体类型别名;
    // 定义时直接使用别名
    结构体类型别名 结构体变量;
    ```
* 结构体的存储
    * 压缩: gcc 编译指令 `__attribute__((packed))`
        ```c++
        struct mystruct11
        {               // 1字节对齐    4字节对齐
            int a;      // 4            4
            char b;     // 1            2(1+1)
            short c;    // 2            2
        } __attribute__((packed));
        ```
    * 对齐: gcc 编译指令 `__attribute__((aligned(n)))`
        ```c++
        struct mystruct111
        {
            int a;
            char b;
            short c;
        } __attribute__((aligned(1024)));    //整个结构体变量整体进行 1024 字节对齐
        ```
    * 压缩并对齐: `__attribute__((packed, aligned(n)))`
        ```c++
        struct ex {
            int source;
            int txSize;
            char datSize;
            char cmd;
        } __attribute__((packed, aligned(1)));
        ```

### 1.4.5. 共用体
> 实际上 `union` 是一个特殊的 `struct`, 所有成员的偏移地址是 0
* 多种数据类型的变量共用内存空间
* 声明
    ```c++
    union 共用体名称 {
        数据类型 成员_1;
        数据类型 成员_2;
        ...
    };
    ```
* 定义
    ```c++
    union 共用体名称 共用体变量;    // 定义时不初始化
    union 共用体名称 共用体变量 = { // 定义时初始化
        成员_1_值,
        成员_2_值,
        ...
    };
    // 仅定义一批变量时
    union {
        数据类型 成员_1;
        数据类型 成员_2;
        ...
    } 共用体变量【= 初始化值】; // 可初始化, 也可不初始化
    ```
* 访问成员
    ```c++
    共用体变量.成员名称     // . 方式
    共用体指针 -> 成员名称  // -> 方式
    ```
* 常用做法
    ```c++
    // 声明时用 typedef 设置别名
    typedef union {
        数据类型 成员_1;
        数据类型 成员_2;
        ...
    } 共用体类型别名;
    // 定义时直接使用别名
    共用体类型别名 共用体变量;
    ```

### 1.4.6. 数组
* 占用一块连续的内存空间
* 声明
    ```c++
    // 声明数组
    数据类型 数组名 [数组长度];
    // 声明并初始化的数组
    数据类型 数组名 [数组长度] = {数组元素列表};
    数据类型 数组名 [] = {数组元素列表};    // 可以不声明长度, 由数组元素列表的个数决定
    // 声明多维数组
    数据类型 数组名 [第 1 维长度][第 2 维长度][...][第 n 维长度];
    // 声明并初始化的多维数组
    数据类型 数组名 [第 1 维长度][第 2 维长度][...][] = // 最后 1 维可以不声明长度, 由数组元素列表的个数决定
        {
            {
                第 2 维数组元素列表
            },  // 第 1 维数组的第 1 个元素
            {
                第 2 维数组元素列表
            },  // 第 1 维数组的第 2 个元素
            ...
            {
                第 2 维数组元素列表
            },  // 第 1 维数组的最后 1 个元素
        };      // 内嵌的括号可以省略
    ```
    * 多维数组本质上还是一维数组, 仍可通过偏移量进行索引
* 访问
    ```c++
    数组名[索引]        // 方式 1
    * (数组名 + 索引)   // 方式 2: c 语言实际将方式 1 转为方式 2
    // 多维数组
    数组名[第 1 维索引][第 2 维索引][...][第 n 维索引]  // 方式 1
    ```
    * 数组的索引从 0 开始
* 数组的地址
    ```c++
    数组名      // 方式 1
    & 数组名[0] // 方式 2
    ```
* 初始化
    * 声明时, 可以一次性全部初始化
    * 如果声明时未初始化, 需要逐个元素初始化

### 1.4.7. 指针
* 声明与定义
    ```c++
    // 声明并初始化
    数据类型 * 指针【 = 变量 】;
    // 声明
    数据类型 * 指针;    // 声明时最好初始化为 NULL
    ...
    指针 = & 变量;
    ```
* 相关运算符
    * `*` 运算符: 取指针指向的变量的值, 优先级非常高
    * `&` 运算符: 获取变量的地址, 优先级非常高
    * `+` `-` `++` `--` 指针偏移运算:
        * 指针的偏移量与其类型相关, 例如:
            * `char *` 型指针偏移单位为 1 byte
            * `int *` 型指针偏移单位为 4 byte
            * `double *` 型指针偏移单位为 8 byte
* 多重指针
    ```c++
    数据类型 ** 指针;   // 指针的指针, 用于指向指针
    数据类型 *** 指针;
    ...
    ```
* 指针与常量
    * 常量指针:
        ```c++
        int const* p;
        const int* p;   // 总之 const 在 * 之前, 用来修饰 *
        ```
        * 指向常量, 所取的值不能改变
        * 但可以重新指向其他变量
    * 指针常量:
        ```c++
        int* const p;   // const 在 * 之后, 用来修饰指针 p
        ```
        * 指针本身是常量, 指向的地址不可改变
        * 指针的取值可以改变
    * 指向常量的常指针
        ```c++
        const int* const p;
        ```
        * 指向的地址不可改变
        * 指针的取值也不可改变
    * 三种特殊指针的示例
        ```c++
        // ----- 常量指针 -----
        const int *p1 = &a;
        a = 300;        // OK, 仍然可以通过原来的声明修改值
        // *p1 = 56;    // Error, *p1 是 const int 的, 不可修改, 即常量指针不可修改其指向地址
        p1 = &b;        // OK, 指针还可以指向别处, 因为指针只是个变量, 可以随意指向
        // ----- 指针常量 -----
        int* const p2 = &a;
        a = 500;        // OK, 仍然可以通过原来的声明修改值
        *p2 = 400;      // OK, 指针是常量, 指向的地址不可以变化,但是指向的地址所对应的内容可以变化
        // p2 = &b;     // Error, 因为 p2 是 const 指针, 因此不能改变 p2 指向的内容
        // ----- 指向常量的常量指针 -----
        const int* const p3 = &a;
        // *p3 = 1;     // Error
        // p3 = &b;     // Error
        a = 5000;       // OK, 仍然可以通过原来的声明修改值
        ```
* 指针与数组
    * 数组指针: 一个指针, 指向数组首地址
        * 由于 `数组[索引]` 运算等效于 `*(数组 + 索引)`, 因此以下操作等效
            ```c++
            #include <stdio.h>
            int main() {

                int arr[] = { 1,2,3,4,5 };
                int* p = arr;

                printf("*(p + 1) == arr[1] ? => %s\n", *(p + 1) == arr[1] ? "true" : "false");  // true
                printf("*(p + 1) == p[1]   ? => %s\n", *(p + 1) == p[1] ? "true" : "false");    // true

                p += 3;
                printf("*(p)     == arr[3] ? => %s\n", *(p) == arr[3] ? "true" : "false");  // true
                printf("p[-1]    == arr[2] ? => %s\n", p[-1] == arr[2] ? "true" : "false"); // true

                return 0;
            }
            ```
    * 指针数组: 每个元素都是一个指针
        ```c++
        数据类型 * 指针数组[数组长度];  // 或
        数据类型 * 指针数组[] = {指针数组元素列表};
        ```
* 指针与函数
    * 函数指针
        * 声明:
            ```c++
            void 或函数返回值类型 (* 函数指针) (参数列表);
            // "void 或函数返回值类型 * 函数 (参数列表)" 表示返回值是指针的函数
            ```
        * 定义
            ```c++
            // 赋值
            函数指针 = & 函数名;    // `&` 可以省略
            函数指针 = 函数名;
            // 调用
            【返回值 =】函数指针(实参列表);
            ```
        * 可用函数指针实现回调函数
    * 返回值为指针的函数
        ```c++
        返回值的数据类型 * 函数名(参数列表);
        ```

### 1.4.8. 自定义数据类型
* `#define 自定义类型 原数据类型`
* `typedef 原数据类型 自定义类型`
* 区别
    * `typedef` 仅限于为类型定义符号名称, `#define` 不仅可以为类型定义别名, 也能为数值定义别名, 比如可以定义 1 为 ONE
    * `typedef` 是由编译器执行解释的, `#define` 语句是由预编译器进行处理的

### 1.4.9. 强制类型转换
* 显式
    ```c++
    (目标数据类型) 变量或表达式
    ```
* 隐式
    * 整数提升: 小于 `int` 或 `unsigned int` 的整数类型转换为 `int` 或 `unsigned int`
    * 算术转换: `int` -> `unsigned int` -> `long` -> `unsigned long` -> `long long` -> `unsigned long long` -> `float` -> `double` -> `long double`

### 1.4.10. 数据类型的选用
* 整数最好使用 `int` 或 `unsigned int`, 因为内存访问机制, `int` 或 `unsigned int` 更快
* 浮点数最好使用 `double`, 因为标准库的浮点处理函数通常使用 `double`, 如果类型不一致, 会触发类型转换, 反倒影响效率

## 1.5. 变量与值

### 1.5.1. 变量
* 定义:
    ```c++
    数据类型 变量【 = 值】;
    数据类型 变量_1【 = 值_1】, 变量_2【= 值_2】, ...;
    ```
* 赋值: `变量名 = 值;`

### 1.5.2. 特殊变量
* 静态变量
    * 用 `static` 修饰:
        ```c++
        static 数据类型 变量【 = 值】;
        ```
    * 具有全局生命周期, 不会随着被调函数的推出而清除
    * `static` 全局变量仅在其所在文件内有效, 不能被 `extern` 访问
* 外部变量
    * 用 `extern` 修饰
        ```c++
        extern 数据类型 变量;   // 只能声明, 不能定义 (即不能赋初值)
        ```
    * 可导入普通全局变量 (全局变量对所有的程序文件都是可见的)
        * 不可导入 `static` 限定的全局变量

### 1.5.3. 数值常量
* 整数
    * 用 `char`, `int`, `long long` 类型存储
        * `char` 型常量除了用数字表示外, 也可以用 `'单字符'` 表示, 如 `'A'`( = 0x41 = 65)
            > 注意 `'A'` 和 `"A"` 不同, 前者是数值 `0x41`, 后者是数组 `{'A', '\0'}`
    * 后缀
        * 无符号整数常数常用 `u` 或 `U` 结尾
        * `long` 类型的常量常用 `l` 或 `L` 结尾, 如 `123456789L`
            * 无符号 `long` 类型的常用 `ul` 或 `UL` 结尾
        * `long long` 类型常数常用 `ll` 或 `LL` 结尾
            * 无符号 `long long` 类型的常用 `ull` 或 `ULL` 结尾
    * 十六进制表示: `<0x|0X>hh` 或 `'\xhh'`
    * 八进制表示: `'\ooo'`
    * 二进制表示: `<0b|0B>xxx`, 如 `0b101`
        > 不是所有编译器都支持, GCC 支持
* 浮点数
    * 普通表示法 `ddd.ddd`, 如: `1.23`
    * 科学计数法 `ddd.ddd<e|E>[+|-]ddd`, 如: `4.5E-6`
    * 后缀: `f` 或 `F`

### 1.5.4. 字符串常量
* 双引号 `"字符串"` 包裹的内容
    * 常用 `char` 数组存储, 实际存储内容为 `全部字符 + '\0'`
    > 注意: 单引号 `'字符'` 包裹的内容是 `char` 常量, 不是字符串
* 转义符
    | 转义字符 | 描述             |
    | :------: | ---------------- |
    |   `\a`   | 响铃             |
    |   `\b`   | 退格 (Backspace) |
    |   `\f`   | 换页             |
    |   `\n`   | 换行             |
    |   `\r`   | 回车             |
    |   `\t`   | 横向制表符       |
    |   `\v`   | 纵向制表符       |
    |   `\\`   | 反斜杠符号       |
    |   `\?`   | 问号             |
    |   `\'`   | 单引号           |
    |   `\"`   | 双引号           |
    |  `\ooo`  | 八进制数         |
    |  `\xhh`  | 十六进制数       |
    |   `\0`   | Null             |

### 1.5.5. const 变量
* 语法:
    ```c++
    const 数据类型 变量 = 值;   // 必须在定义时赋值
    ```
* 与 `#define 常量 值` 的区别
    * 编译器处理方式不同
        * `#define` 宏是在预处理阶段展开
        * `const` 常量是编译运行阶段使用
    * 类型和安全检查不同
        * `#define` 宏没有类型, 不做任何类型检查, 仅仅是展开
        * `const` 常量有具体的类型, 在编译阶段会执行类型检查
    * 存储方式不同
        * `#define` 宏仅仅是展开, 有多少地方使用, 就展开多少次, 不会分配内存 (宏定义不分配内存, 变量定义分配内存)
        * `const` 常量会在内存中分配 (可以是堆中也可以是栈中)
    * `const` 可以节省空间, 避免不必要的内存分配, 例如:
        ```c++
        #define NUM 3.14159         // 常量宏
        const doulbe num = 3.14159; // 此时并未将Pi放入ROM中

        double i = num;             // 此时为 Pi 分配内存, 以后不再分配
        double I = NUM;             // 编译期间进行宏替换, 分配内存
        double j = num;             // 没有内存分配
        double J = NUM;             // 再进行宏替换, 又一次分配内存
        ```
        * `const` 定义常量从汇编的角度来看, 只是给出了对应的内存地址, `#define` 给出的是立即数, 所以:
            * `const` 定义的常量在程序运行过程中只有一份拷贝 (因为是全局的只读变量, 存在静态区)
            * `#define` 定义的常量在内存中有若干个拷贝
    * 提高了效率
        * 编译器通常不为普通 `const` 常量分配存储空间, 而是将它们保存在符号表中, 这使得它成为一个编译期间的常量, 没有了存储与读内存的操作, 使得它的效率也很高

## 1.6. 运算符

### 1.6.1. 基本运算符
* 算术运算符 (均支持 `运算=`)
    | 运算符 | 含义  | 实例                                                         |
    | :----: | :---: | :----------------------------------------------------------- |
    |  `+`   |  正   | +1.2, +0                                                     |
    |  `-`   |  负   | -3.4, -0                                                     |
    |  `+`   |  加   | 1 + 3 => 4                                                   |
    |  `-`   |  减   | 5.3 - 3.2 => 2.1                                             |
    |  `*`   |  乘   | 2 * 3 => 6                                                   |
    |  `/`   |  除   | 7 / 2 => 3, 7 / 2.0 => 3.5, 7.0 / 2 => 3.5, 7.0 / 2.0 => 3.5 |
    |  `%`   | 取余  | 5 % 2 => 1                                                   |
    * 取余只能针对整数, 余数可以是正数也可以是负数, 由 `%` 左边的整数决定
* 自增和自减
    |  运算符  |     含义      | 实例                     |
    | :------: | :-----------: | :----------------------- |
    | `变量++` | 先返回, 后加1 | int a = 1; a++; // a = 1 |
    | `++变量` | 先加1, 后返回 | int a = 1; ++a; // a = 2 |
    | `变量--` | 先返回, 后减1 | int a = 1; a--; // a = 1 |
    | `--变量` | 先减1, 后返回 | int a = 1; --a; // a = 0 |
* 赋值运算符
    |    表达方式     | 含义           | 实例       |
    | :-------------: | -------------- | ---------- |
    |       `=`       | 向左赋值       | a = 3;     |
    |     连 `=`      | 连续向左赋值   | a = b = 3; |
    | `+=`, `-=`, ... | 先运算, 后赋值 | a += 1;    |
* 比较运算符
    | 运算符 |    描述    | 实例              |
    | :----: | :--------: | :---------------- |
    |  `==`  |   相等 ?   | (1 == 2) => false |
    |  `!=`  |   不等 ?   | (1 != 2) => true  |
    |  '`>`  |   大于 ?   | (1 > 2) => false  |
    |  `<`   |   小于 ?   | (1 < 2) => true   |
    |  `>=`  | 大于等于 ? | (1 >= 2) => false |
    |  `<=`  | 小于等于 ? | (1 <= 1) => true  |
* 位运算符 (除 `~`外, 均支持 `运算=`)
    | 运算符 |   描述   | 实例                      |
    | :----: | :------: | ------------------------- |
    |  `&`   |  按位与  | 0b1100 & 0b0101 => 0b0100 |
    |   `    |    `     | 按位或                    | 0b1100 \| 0b0101 => 0b1101 |
    |  `~`   | 按位取反 | ~0b1100 => 0b0011         |
    |  '`^`  | 按位异或 | 0b1100 ^ 0b0101 => 0b1001 |
    |  `<<`  |   左移   | 0xff << 2 => 0x3fc        |
    |  `>>`  |   右移   | 0xff >> 2 => 0x3f         |
* 逻辑运算符
    | 运算符 |  描述  | 实例                   |
    | :----: | :----: | :--------------------- |
    |  `&&`  | 逻辑与 | true && false => false |
    |   `    |        | `                      | 逻辑或 | true \|\| false => true |
    |  `!`   | 逻辑非 | ! true = false         |

### 1.6.2. 特殊运算符
* `* 指针`: 获取指针指向的变量的值
* `& 变量`: 获取变量的地址
* `sizeof (数据类型或变量)`: 返回变量的内存占用 (单位 byte)
* `?:`: 三元操作
    ```c++
    逻辑表达式 ? 真值对应的表达式 : 假值对应的表达式;
    ```

### 1.6.3. 运算符优先级
| 优先级 |                                    运算符                                     | 结合性         |
| :----: | :---------------------------------------------------------------------------: | -------------- |
|   高   |                              `()` `[]` `.` `->`                               | 从左到右       |
|   ↓    | `!` `~` `++` `--` `+(正)` `-(负)` `*(指针取值)` `&(取地址)` `(类型)` `sizeof` | 从右到左       |
|   ^    |                                  `*` `/` `%`                                  | 从左到右       |
|   ^    |                                `+(加)` `-(减)`                                | ^              |
|   ^    |                                   `<<` `>>`                                   | ^              |
|   ^    |                               `<` `<=` `>` `>=`                               | ^              |
|   ^    |                                   `==` `!=`                                   | ^              |
|   ^    |                                  `&(按位与)`                                  | ^              |
|   ^    |                                     '`^`                                      | ^              |
|   ^    |                                       `                                       | `              | ^        |
|   ^    |                                     `&&`                                      | ^              |
|   ^    |                                       `                                       |                | `        | ^ |
|   ^    |                                     `?:`                                      | ^              |
|   ^    |                   `=` `+=` `-=` `*=` `/=` `%=` `&=` `^=` `                    | =` `<<=` `>>=` | 从右到左 |
|   低   |                                      `,`                                      | 从右到左       |

### 1.6.4. 一些巧妙的运算
* 值交换
    ```c++
    a = a ^ b //
    b = a ^ b // b = a ^ b ^ b = a ^ (b ^ b) = a ^ 0 = a
    a = a ^ b // a = a ^ b_old ^ b_new = a ^ b_old ^ a = b_old ^ a ^a = b_old
    ```
    或
    ```c++
    a = a + b //
    b = a - b // b = a + b - b = a
    a = a - b // a = a + b_old - b_new = a + b_old - a = b_old
    ```
* 判断一个整数是否为 2 的整数次幂
    ```c++
    (num > 0) && ((num & (num - 1)) == 0)   // 如果为真, 则 m 是 2 的整数次幂
    ```
* 按 2^n 对齐
    ```c++
    (addr + (align - 1)) & ~(align - 1)     // 先加偏移量, 然后将低 n 位清零
    ```
    等效于 $floor(\dfrac{addr + align -1} {align}) * align$


## 1.7. 程序控制
> C 语言中: 0 或 null 为 false, 其余为 true

### 1.7.1. 条件控制
* **if...else...**
    ```c++
    if (逻辑表达式) {
        代码块
    } else {
        代码块
    }
    ```
* **if...else if...else...**
    ```c++
    if (逻辑表达式 1) {
        代码块
    } else if (条件表达式 2) {
        代码块
    }
    ...
      else if (条件表达式 n) {
        代码块
    } else {
        代码块
    }
    ```
* **switch...case...break...default...**
    ```c++
    switch (逻辑表达式){
        case 值 1:
            代码块
            break;  // 可选, 如果没有, 回执行后续代码, 直到 break
        case 值 2:
            代码块
            break; // 可选
        ....
        case 值 n:
            代码块
            break;  // 可选
        default :   // 可选, 可以在任意位置, 但不在最后时注意是否需要 break
            代码块  // 如果没有与表达式相同的值, 则执行该代码
    }
    ```
* **?:**
    ```c++
    逻辑表达式 ? 真值对应的表达式 : 假值对应的表达式;
    ```

### 1.7.2. 循环控制
* **while...**
    ```c++
    while (逻辑表达式) {
        代码块
    }
    ```
* **do...while...**
    ```c++
    do {
        代码块
    } while (逻辑表达式);
    ```
* **for...**
    ```c++
    for(初始化; 逻辑表达式; 偏移) {
        代码块
    }
    ```
* 循环控制:
    * `break`: 跳出循环
    * `continue`: 立即进入下次循环

### 1.7.3. goto
```c++
    goto 标签;
    ...
标签:
    代码块
```

## 1.8. 函数

### 1.8.1. 声明
> 通常在 "xxx.h" 头文件中声明, 在 "xxx.c" 文件中定义
* 语法
    ```c++
    // 无返回值的函数
    void 函数名 (形参列表);
    // 有返回值的函数
    返回值的数据类型 函数名 (形参列表);
    ```
* 参数: `数据类型 参数名`
    * 在声明时, 可以不写参数名
    * 定义时的参数名可以和声明时的不一样

### 1.8.2. 定义
* 语法
    ```c++
    // 无返回值的函数
    void 函数名 (形参列表) {
        函数体
    }
    // 有返回值的函数
    返回值的数据类型 函数名 (形参列表) {
        函数体
        return 返回值;
    }
    ```
* 可变参数
    * 形式: `返回值类型 函数 (int 参数个数, ...)`
    * 工作原理
        * 调用函数时, 实参依次压入栈中, 根据最后一个固定参数的地址可以计算出其余可变参数的地址
    * 需要使用 `stdarg.h` 头文件 (该文件提供了实现可变参数功能的函数和宏), 具体步骤如下
        1. 定义一个函数 `返回值类型 函数 (int 参数个数, ...)`
        1. 在函数定义中创建 `va_list` 类型的变量
        1. 调用 `va_start(va_list变量, 最后一个固定参数)` 宏来初始化 `va_list`
        1. 调用 `va_arg(va_list变量, 可变参数的类型)` 来访问参数列表中的每个项
        1. 调用 `va_end(va_list变量)` 来清理赋予 `va_list` 变量的内存
    * 示例
        ```c++
        #include <stdio.h>
        #include <stdarg.h>

        double average(int num, ...) {      // 1. 定义可变参数函数
            va_list valist;                 // 2. 创建 va_list 类型的变量
            double sum = 0.0;

            va_start(valist, num);          // 3. 调用 va_start 以初始化 valist
            for (int i = 0; i < num; i++) {
                sum += va_arg(valist, int); // 4. 调用 va_arg 访问参数列表中的每个项
            }
            va_end(valist);                 // 5. 调用 va_end 清理 valist
            return sum / num;
        }

        int main() {
            printf("Average of 2, 3, 4, 5 = %f\n", average(4, 2, 3, 4, 5));
            printf("Average of 5, 10, 15 = %f\n", average(3, 5, 10, 15));
        }
        ```
* 默认参数
    * C 语言不支持默认参数
    * 可用宏来模拟参数默认值
        ```c++
        #define fun1(a) fun(a, 10)  // fun1 用来模拟 fun 的默认参数
        int fun(int a, int b);
        ```
* 特殊参数
    * 指针: `参数的数据类型 * 指针`
        > C 语言不支持引用参数 (形式: `参数的数据类型 & 参数名`)
    * 数组:
        * 一维数组: `参数的数据类型 数组名[长度]` 或 `参数的数据类型 数组名[]`
            * 也可以用指针传递: `参数的数据类型 * 指针`
        * 多维数组: `参数的数据类型 数组名[第 1 维长度][第 2 维长度][...][第 n 维长度]`
            * 第 1 维长度可以省略
            * 也可以用指针数组传递: `参数的数据类型 (*指针) [第 2 维长度][...][第 n 维长度]`
            * 也可以用指针传递: `参数的数据类型 * 指针`
* `return 返回值`
    * 可以是任何类型
    * 返回数组
        * 需要在函数内部将需要返回的数组定义为 `static` 变量
            * C 不支持在函数外返回局部变量的地址
        * 返回值类型应为指针
        * 更常用的做法: 不使用返回值, 而是在函数外部定义好数组, 然后引用传递到函数内部, 函数结束后该数组已被处理好

### 1.8.3. 调用
* 语法
    ```c++
    // 无返回值函数的调用
    函数名(实参列表);
    // 有返回值函数的调用
    返回值 = 函数名(实参列表);
    ```
* 参数传递:
    * 顺序需一致
    * 值传递与引用传递
        * 值传递:
            * 基本数据类型
            * `enum`, `union`, `struct`
        * 引用传递:
            * 指针
            * 数组
            * 字符串
            * 函数
* 递归调用
    ```c++
    #include <stdio.h>

    double factorial(unsigned int i) {
        if (i <= 1) {
            return 1;
        }
        return i * factorial(i - 1);    // 递归调用
    }

    int  main() {
        int i = 15;
        printf("(%d)! = %f\n", i, factorial(i));
        return 0;
    }
    ```
### 1.8.4. 主函数
* 主函数是一个程序唯一的入口
* 语法
    ```c++
    // 标准写法
    int main(int argc, char *argv[] ){
            ...
        return 0_或错误代码;
    }
    // 简化写法
    int main(){
            ...
        return 0_或错误代码;
    }
    ```
    * `argc` 和 `argv` 是 `main` 函数的形式参数
        * 这两个形式参数的类型是系统规定的, 如果 `main` 函数要带参数, 就是这两个类型的参数; 否则 `main` 函数就没有参数
        * 参数的个数传递给 `argc`
        * 可执行文件名称 (包括路径名称) 作为一个字符串, 其首地址被赋给 `argv[0]`, 参数1也作为一个字符串, 首地址被赋给 `argv[1]`, 依次类推, ...

### 1.8.5. 特殊函数
* 内部函数/静态函数
    * 用 `static` 修饰
        ```c++
        static 返回值的数据类型 函数名 (形参列表);  // 声明
        static 返回值的数据类型 函数名 (形参列表){  // 定义
            ...
        };
        ```
    * 只能在本文件中使用, 不能被 `extern` 访问
* 外部函数
    * 用 `extern` 声明
        ```c++
        extern 返回值的数据类型 函数名 (形参列表);  // 声明
        ```
* 内联函数
    * 用 `inline` 修饰
        ```c++
        inline 返回值的数据类型 函数名 (形参列表);  // 声明
        inline 返回值的数据类型 函数名 (形参列表){  // 定义
            ...
        };
        ```
    * 用来消除函数调用时的时间开销, 通常用于频繁执行的函数, 对于小内存空间的函数非常受益, 编译后不具备函数性质
    * 注意:
        * 递归函数不能定义为内联函数
        * 内联函数一般适合于不存在 `while` 和 `switch` 等复杂的结构且只有 1~5 条语句的小函数上, 否则编译系统将该函数视为普通函数
        * 内联函数只能先定义后使用, 否则编译系统也会把它认为是普通函数
        * 对内联函数不能进行异常的接口声明

## 1.9. 作用域与生命周期
* 作用域
    * 全局作用域
        * 函数外部的变量
        * 普通的全局变量可被所有文件访问 (可用 `extern` 引入)
            * `static` 全局变量除外
        * 全局变量如果未显式初始化, 系统会自动初始化
            | 数据类型 | 初始化默认值 |
            | :------: | :----------: |
            |   int    |      0       |
            |   char   |     '\0'     |
            |  float   |      0       |
            |  double  |      0       |
            | pointer  |     NULL     |
    * 局部作用域
        * 在函数内部声明的变量, 只能在函数内使用
        * 局部变量和全局变量的名称可以相同, 但是在函数内, 如果两个名字相同, 会使用局部变量
* 生命周期
    * 全局变量: 整个程序生命周期
    * 局部变量:
        * 普通局部变量: 函数执行完毕后会被立即销毁
        * `static` 局部变量: 整个程序生命周期

## 1.10. 内存管理

### 1.10.1. 数据存放
* 全局变量: 位于静态存储区
* 局部变量:
    * 普通变量: 使用栈, 调用时调用者将参数入栈, 函数使用, 函数结束时退栈, 参数基本
    * `static` 局部变量: 位于静态存储区, 与函数的堆栈区不在同一个区域
* 动态内存: 位于 heap

### 1.10.2. 动态内存分配
* 头文件 `#include <stdlib.h>`
    ```c++
    void *calloc(int num, int size);// 在 heap 中动态分配 num 个长度为 size 的连续空间, 并将所有字节零初始化
    void free(void *address);       // 释放 heap 中 address 所指向的内存块
    void *malloc(int num);          // 在 heap 中分配一块指定大小的内存空间, 该内存空间未被初始化
    void *realloc(void *address, int newsize);  // 重新分配内存, 把内存扩展到 newsize
    ```

### 1.10.3. 数据对齐
* 对齐: gcc 编译指令 `变量 __attribute__((aligned(n)));`

## 1.11. 预处理

### 1.11.1. 预处理命令
* `#`: 把一个宏的参数转换为字符串常量
* `##`: 连接预处理字符串
* `#define`: 宏定义
* `#undef`: 取消定义变量
* `#if`, `#ifdef`, `#ifndef`, `#else`, `#elif`, `#endif`: 条件操作符
* `#include`: 插入其它文件的内容
* `#error`: 显示一个错误消息
* `#line`: 设置行和文件信息
* `#pragma`: 使用标准化方法, 向编译器发布特殊的命令到编译器中

### 1.11.2. 预定义宏
| 宏         | 描述                                              |
| :--------- | :------------------------------------------------ |
| \_\_DATE__ | 当前日期, 一个以 "MMM DD YYYY" 格式表示的字符常量 |
| \_\_TIME__ | 当前时间, 一个以 "HH:MM:SS" 格式表示的字符常量    |
| \_\_FILE__ | 这会包含当前文件名, 一个字符串常量                |
| \_\_LINE__ | 这会包含当前行号, 一个十进制常量                  |
| \_\_STDC__ | 当编译器以 ANSI 标准编译时, 则定义为 1            |

### 1.11.3. 头文件
* 两种形式
    * `#include "头文件"`: 一般形式
        * 引用的是程序目录的相对路径中的头文件, 如果在程序目录没有找到引用的头文件则到编译器的类库路径的目录下找该头文件
    * `#include <头文件>`: 专用于引用系统头文件
* 只引用一次头文件
    * 如果一个头文件被引用两次, 编译器会处理两次头文件的内容, 这将产生错误。为了防止这种情况, 标准的做法是把文件的整个内容放在条件编译语句中, 如下:
        ```c++
        #ifndef 宏
        #define 宏

        头文件内容

        #endif
        ```

## 1.12. 输入/输出

### 1.12.1. 标准输入/输出
* 标准库头文件
    ```c++
    #include <stdio.h>
    ```
* 标准输入 `stdin`: 键盘
    ```c++
    int scanf(const char *format, ...); // 从 stdin 读取输入, 并根据提供的 format 来浏览输入
    int getchar(void);   // 从 stdin 读取下一个可用的字符, 并把它返回为一个整数
    char *gets(char *s); // 从 stdin 读取一行到 s 所指向的缓冲区, 直到一个终止符或 EOF
    ```
* 标准输出 `stdout`: 屏幕
    ```c++
    int printf(const char *format, ...); // 函数把输出写入到 stdout, 并根据提供的格式产生输出
    int putchar(int c);      // 函数把字符写入到 stdout, 并返回相同的字符
    int puts(const char *s); // 函数把字符串 s 和一个尾随的换行符写入到 stdout
    ```
* `format` 格式: `[符号][宽度][.精度][长度]类型`
    | 分类  | 格式描述符 | 说明                                                                                   |
    | :---: | :--------: | -------------------------------------------------------------------------------------- |
    | 符号  |     +      | 正负数均加符号                                                                         |
    |   ^   |     -      | 负数前加负号 (-), 正数前不加符号 (默认)                                                |
    |   ^   |   (空格)   | 负数前加负号 (-), 正数前加一个空格                                                     |
    |   ^   |     #      | 对 `o` 和 `x/X`: 数字加前缀 `o` 或 `0x` <br/>对`e`,`g`,`f`: 当结果有小数时才给出小数点 |
    | 宽度  |   <宽度>   | 指定宽度                                                                               |
    |   ^   |  0<宽度>   | 指定宽度, 并添加前导零                                                                 |
    | 精度  |   <精度>   | 仅用于浮点数, 对应的类型应为 `f/F` 或 `g/G`                                            |
    | 长度  |     h      | 短整型 (如 `hd`, `hu`)                                                                 |
    |   ^   |     l      | 长整型 (如 `ld`, `lu`) 或 `double` (`lf`)                                              |
    | 类型  |     d      | 十进制整数                                                                             |
    |   ^   |     u      | 十进制无符号整数                                                                       |
    |   ^   |     i      | 十进制有符号整数                                                                       |
    |   ^   |    x/X     | 十六进制整数 (小写/大写)                                                               |
    |   ^   |     o      | 八进制整数                                                                             |
    |   ^   |     f      | 定点数, 默认精度是6                                                                    |
    |   ^   |    e/E     | 科学计数                                                                               |
    |   ^   |    g/G     | 通用格式, 小数用 `f/F`, 大数用 `e/E`                                                   |
    |   ^   |     c      | 字符                                                                                   |
    |   ^   |     s      | 普通字符串                                                                             |
    |   ^   |     p      | 指针的地址                                                                             |
    | 其他  |     %      | 百分号本身                                                                             |

    * 注意
        * `printf` 时: `double` 和 `float` 都可以用 `%f` 占位符, 可以混用, 而 `double` 可以额外用 `%lf`
        * `scanf` 输入情况下 `double` 必须用 `%lf`, `float` 必须用 `%f`, 不能混用

### 1.12.2. 标准错误
* C 语言不提供对错误处理的直接支持, 但是作为一种系统编程语言, 它以返回值的形式允许您访问底层数据
    * 在发生错误时, 大多数的 C 或 UNIX 函数调用返回 `1` 或 `NULL`, 同时会设置一个错误代码 `errno`, 该错误代码是全局变量, 表示在函数调用期间发生了错误
    * 可以在 `errno.h` 头文件中找到各种各样的错误代码
    * 开发人员应该在程序初始化时, 把 `errno` 设置为 0 (表示程序中没有错误), 这是一种良好的编程习惯
* `errno`, `perror()` 和 `strerror()`
    * `perror()` 函数显示字符串, 后跟一个冒号、一个空格和当前 `errno` 值的文本表示形式
    * `strerror()` 函数, 返回一个指针, 指针指向当前 `errno` 值的文本表示形式
    * 示例
        ```c++
        #include <stdio.h>
        #include <errno.h>
        #include <string.h>

        extern int errno;

        int main() {
            FILE* pf;
            int errnum;
            pf = fopen("unexist.txt", "rb");
            if (pf == NULL) {
                errnum = errno;
                fprintf(stderr, "错误号: %d\n", errno);
                perror("通过 perror 输出错误");
                fprintf(stderr, "打开文件错误: %s\n", strerror(errnum));
            }
            else {
                fclose(pf);
            }
            return 0;
        }
        ```

### 1.12.3. 文件访问
* API, 详见 [<stdio.h>](#215-stdioh)
    ```c++
    // 打开文件
    FILE *fp;   // 文件变量
    FILE *fopen(const char *filename, const char *mode);
    // 读取
    int fscanf(FILE *fp, char *format, ...)
    int getc(FILE *fp);
    char *fgets(char *buf, int n, FILE *fp);
    // 写入
    int fprintf(FILE *fp, char *format, ...);
    int putc(int c, FILE *fp);
    int fputs(const char *s, FILE *fp);
    // 关闭文件
    int fclose(FILE *fp)
    // 文件信息
    int fseek(FILE *stream, long offset, int whence);
    ```
* 文件打开模式: `mode`
    |          模式          | 描述                                               |
    | :--------------------: | -------------------------------------------------- |
    |           r            | 只读, 文件指针在文件头, 默认                       |
    |           w            | 只写, 若存在, 删除原内容, 从头编辑; 若不存在, 创建 |
    |           x            | 若不存在, 创建; 否则, 报错                         |
    |           a            | 若存在, 追加; 若不存在, 创建                       |
    |     [r\|w\|x\|a] b     | 二进制模式                                         |
    |     [r\|w\|x\|a] t     | 文本模式 (默认)                                    |
    | [r\|w\|x\|a] [b\|t]\ + | 读写模式, 若不存在, r+报错, w+和a+则创建文件       |

--------------------------------------------------------------------------------
# 2. 标准库

## 2.1. <assert.h>
* `void assert(expr)`
    * 本质是: `# define assert(expr)   ((void)0)`
    * 调试程序时经常使用的宏, 在程序运行时它计算括号内的表达式
        * 如果表达式为 FALSE (0), 程序将报告错误, 并终止执行
        * 如果表达式不为 0, 则继续执行后面的语句
    * 通常用于判断程序中是否出现了明显非法的数据, 如果出现了终止程序以免导致严重后果, 同时也便于查找错误
    * 只有在 Debug 版本中才有效, 如果编译为 Release 版本则被忽略

## 2.2. <ctype.h>
* 库函数
    * `int isalnum(int c)`: 是否为字母和数字
    * `int isalpha(int c)`: 是否为字母
    * `int iscntrl(int c)`: 是否为控制字符
    * `int isdigit(int c)`: 是否为十进制数字
    * `int isgraph(int c)`: 是否为图形表示法
    * `int islower(int c)`: 是否为小写字母
    * `int isprint(int c)`: 是否为可打印字符
    * `int ispunct(int c)`: 是否为标点符号字符
    * `int isspace(int c)`: 是否为空白字符
    * `int isupper(int c)`: 是否为大写字母
    * `int isxdigit(int c)`: 是否为十六进制数字
        <br/>
    * `int tolower(int c)`: 转换为小写字母
    * `int toupper(int c)`: 转换为大写字母
* 相关定义
    |    字符类    | 描述                                                                                                                                 |
    | :----------: | :----------------------------------------------------------------------------------------------------------------------------------- |
    |     数字     | `[0-9]`                                                                                                                              |
    | 十六进制数字 | `[0-9A-Fa-f]`                                                                                                                        |
    |   小写字母   | `[a-z]`                                                                                                                              |
    |   大写字母   | `[A-Z]`                                                                                                                              |
    |     字母     | `[A-Za-z]`                                                                                                                           |
    | 字母数字字符 | `[A-Za-z0-9]`                                                                                                                        |
    | 标点符号字符 | `!` `"` `#` `$` `%` `&` `'` `(` `)` `*` `+` `,` `-` `.` `/` `:` `;` `<` `=` `>` `?` `@` `[` `\` `]` `^` `_` ``` ` ``` `{` \| `}` `~` |
    |   图形字符   | 字母、数字、字符、标点符号字符                                                                                                       |
    |   空格字符   | 制表符、换行符、垂直制表符、换页符、回车符、空格符                                                                                   |
    |  可打印字符  | 字母数字字符、标点符号字符、空格字符                                                                                                 |
    |   控制字符   | 在 ASCII 编码中, 这些字符的八进制代码是从 000 到 037, 以及 177 (DEL)                                                                 |
    |   空白字符   | 空格符、制表符                                                                                                                       |

## 2.3. <errno.h>
* 定义了整型全局变量 `errno` (`extern int errno`): 通过系统调用设置的宏, 在错误事件中的某些库函数表明了什么发生了错误
* 定义了一系列表示不同错误代码的宏 (其值均为非零值), 其中常见的有
    * `EDOM`: 表示一个域错误, 它在输入参数超出数学函数定义的域时发生
    * `ERANGE`: 表示一个范围错误, 它在输入参数超出数学函数定义的范围时发生

## 2.4. <float.h>
* 定义了一组与浮点值相关的依赖于平台的常量
    |       宏        | 值    | 描述                                                                                                                                    |
    | :-------------: | :---- | :-------------------------------------------------------------------------------------------------------------------------------------- |
    |   FLT_ROUNDS    | -     | 浮点加法的舍入模式, 可取的值: <br/> -1 - 无法确定 <br/> 0 - 趋向于零 <br/> 1 - 去最近的值 <br/> 2 - 趋向于正无穷 <br/> 3 - 趋向于负无穷 |
    |    FLT_RADIX    | 2     | 指数表示的基数                                                                                                                          |
    |  FLT_MANT_DIG   | 24    | FLT_RADIX 基数中的位数                                                                                                                  |
    |  DBL_MANT_DIG   | 53    | ^                                                                                                                                       |
    |  LDBL_MANT_DIG  | ^     | ^                                                                                                                                       |
    |     FLT_DIG     | 6     | 舍入后不会改变表示的十进制数字的最大值 (基数 10)                                                                                        |
    |     DBL_DIG     | 15    | ^                                                                                                                                       |
    |    LDBL_DIG     | 15    | ^                                                                                                                                       |
    |   FLT_EPSILON   | 1E-5  | 可表示的最小有效数字                                                                                                                    |
    |   DBL_EPSILON   | 1E-9  | ^                                                                                                                                       |
    |  LDBL_EPSILON   | 1E-9  | ^                                                                                                                                       |
    |     FLT_MIN     | 1E-37 | 最小的浮点值                                                                                                                            |
    |     DBL_MIN     | 1E-37 | ^                                                                                                                                       |
    |    LDBL_MIN     | 1E-37 | ^                                                                                                                                       |
    |   FLT_MIN_EXP   | -     | 基数为 FLT_RADIX 时的指数的最小负整数值                                                                                                 |
    |   DBL_MIN_EXP   | ^     | ^                                                                                                                                       |
    |  LDBL_MIN_EXP   | ^     | ^                                                                                                                                       |
    | FLT_MIN_10_EXP  | -37   | 基数为 10 时的指数的最小负整数值                                                                                                        |
    | DBL_MIN_10_EXP  | ^     | ^                                                                                                                                       |
    | LDBL_MIN_10_EXP | ^     | ^                                                                                                                                       |
    |     FLT_MAX     | 1E+37 | 最大的有限浮点值                                                                                                                        |
    |     DBL_MAX     | ^     | ^                                                                                                                                       |
    |    LDBL_MAX     | ^     | ^                                                                                                                                       |
    |   FLT_MAX_EXP   | -     | 基数为 FLT_RADIX 时的指数的最大整数值                                                                                                   |
    |   DBL_MAX_EXP   | ^     | ^                                                                                                                                       |
    |  LDBL_MAX_EXP   | ^     | ^                                                                                                                                       |
    | FLT_MAX_10_EXP  | +37   | 基数为 10 时的指数的最大整数值                                                                                                          |
    | DBL_MAX_10_EXP  | ^     | ^                                                                                                                                       |
    | LDBL_MAX_10_EXP | ^     | ^                                                                                                                                       |
    * 注意: 不同的编译器或平台, 这些值可能不同

## 2.5. <iso646.h>
> C99 标准, 并非所有编译器都支持
* 指定了一些常见运算符的替代拼写
    ```c++
    #define and     &&
    #define and_eq  &=
    #define bitand  &
    #define bitor   |
    #define compl   ~
    #define not     !
    #define not_eq  !=
    #define or      ||
    #define or_eq   |=
    #define xor     ^
    #define xor_eq  ^=
    ```

## 2.6. <limits.h>
* 限制了各种变量类型的值
    |     宏     | 值                           | 描述                                |
    | :--------: | :--------------------------- | :---------------------------------- |
    |  CHAR_BIT  | 8                            | 字节的 bits                         |
    | SCHAR_MIN  | (-128)                       | `[signed] char` 型变量的最小值      |
    | SCHAR_MAX  | 127                          | `[signed] char` 型变量的最大值      |
    | UCHAR_MAX  | 0xff                         | `unsigned char` 型变量的最大值      |
    |  CHAR_MIN  | SCHAR_MIN                    | `char` 型变量的最小值               |
    |  CHAR_MAX  | SCHAR_MAX                    | `char` 型变量的最大值               |
    | MB_LEN_MAX | 1                            | 多字节字符中的最大字节数            |
    |  SHRT_MIN  | (-32768)                     | `[signed] short` 型变量的最小值     |
    |  SHRT_MAX  | 32767                        | `[signed] short` 型变量的最大值     |
    | USHRT_MAX  | 0xffffU                      | `unsigned short` 型变量的最大值     |
    |  INT_MIN   | (-2147483647 - 1)            | `[signed] int` 型变量的最小值       |
    |  INT_MAX   | 2147483647                   | `[signed] int` 型变量的最大值       |
    |  UINT_MAX  | 0xffffffffU                  | `unsigned int` 型变量的最大值       |
    |  LONG_MIN  | (-2147483647L - 1)           | `[signed] long` 型变量的最小值      |
    |  LONG_MAX  | 2147483647L                  | `[signed] long` 型变量的最大值      |
    | ULONG_MAX  | 0xffffffffUL                 | `unsigned long` 型变量的最大值      |
    | LLONG_MAX  | 9223372036854775807ll        | `[signed] long long` 型变量的最小值 |
    | LLONG_MIN  | (-9223372036854775807ll - 1) | `[signed] long long` 型变量的最大值 |
    | ULLONG_MAX | 0xffffffffffffffffull        | `unsigned long long` 型变量的最大值 |
    * 注意: 不同的编译器或平台, 这些值可能不同

## 2.7. <locale.h>
* 定义了特定地域的设置, 比如日期格式和货币符号
* 库宏
    * 略
* 库函数
    * 略
* 库结构
    * 略

## 2.8. <malloc.h>
> C99 标准, 并非所有编译器都支持
* 动态内存管理
* 库函数
    ```c++
    void *calloc(size_t nmemb, size_t size);
    void *malloc(size_t size);
    void *realloc(void *ptr, size_t size);
    void free(void *ptr);
    ```

## 2.9. <math.h>
* 库宏
    * `HUGE_VAL`:
        * 如果结果太大以致于无法表示, 则函数会设置 `errno` 为 `ERANGE` 来表示范围错误, 并返回一个由宏 `HUGE_VAL` 或者它的否定 (- `HUGE_VAL`) 命名的一个特定的很大的值
        * 如果结果太小, 则会返回 0, 在这种情况下, `error` 可能会被设置为 `ERANGE`
* 库函数
    * `double sin(double x)`: 返回弧度角 x 的正弦
    * `double cos(double x)`: 返回弧度角 x 的余弦
    * `double tan(double x)`: 返回弧度角 x 的正切
        <br/>
    * `double asin(double x)`: 返回以弧度表示的 x 的反正弦
    * `double acos(double x)`: 返回以弧度表示的 x 的反余弦
    * `double atan(double x)`: 返回以弧度表示的 x 的反正切
    * `double atan2(double y, double x)`: 返回以弧度表示的 y/x 的反正切, y 和 x 的值的符号决定了正确的象限
        <br/>
    * `double sinh(double x)`: 返回 x 的双曲正弦
    * `double cosh(double x)`: 返回 x 的双曲余弦
    * `double tanh(double x)`: 返回 x 的双曲正切
        <br/>
    * `double exp(double x)`: 返回 `e` 的 x 次幂的值
    * `double frexp(double x, int *exponent)`: 把浮点数 x 分解成尾数和指数, 返回值是尾数, 并将指数存入 exponent 中, 所得的值是 x = mantissa * 2 ^ exponent
    * `double ldexp(double x, int exponent)`: 返回 x 乘以 2 的 exponent 次幂
    * `double log(double x)`: 返回 x 的自然对数 (基数为 `e` 的对数)
    * `double log10(double x)`: 返回 x 的常用对数 (基数为 10 的对数)
    * `double pow(double x, double y)`: 返回 x 的 y 次幂
    * `double sqrt(double x)`: 返回 x 的平方根
        <br/>
    * `double fabs(double x)`: 返回 x 的绝对值
    * `double ceil(double x)`: 返回大于或等于 x 的最小的整数值
    * `double floor(double x)`: 返回小于或等于 x 的最大的整数值
        <br/>
    * `double modf(double x, double *integer)`: 返回值为小数部分 (小数点后的部分), 并设置 integer 为整数部分
    * `double fmod(double x, double y)`: 返回 x 除以 y 的余数

## 2.10. <setjmp.h>
* 提供了一种不同于通常的函数调用和返回规则的方式
* 库变量
    * `jmp_buf`: 用于存储 `setjmp()` 和 `longjmp()` 相关信息的数组类型
* 库宏
    * `int setjmp(jmp_buf environment)`: 把当前环境保存在变量 environment 中, 供 `longjmp()` 使用
        * 如果直接调用 `setjmp`, 则返回 0
        * 如果从 `longjmp()` 函数调用中返回, 则会返回一个非零值
* 库函数
    * `void longjmp(jmp_buf environment, int value)`: 恢复最近一次调用 `setjmp()` 宏时保存的环境, 程序重新恢复执行
        * `jmp_buf` 参数的设置是由之前调用 `setjmp()` 生成的

## 2.11. <signal.h>
* 提供了一些处理程序运行期间引发的各种异常条件的功能, 例如来自外部的中断信号或程序执行错误引起的中断信号
* 库变量
    * `sig_atomic_t`: int 类型, 在信号处理程序中作为变量使用, 可以作为一个原子实体访问
* 库宏
    * 信号处理程序
        * `SIG_DFL`: 默认的信号处理程序
        * `SIG_IGN`: 忽视信号
        * `SIG_ERR`: 表示一个信号错误
    * 有效的信号
        * `SIGABRT`: 程序异常终止
        * `SIGFPE`: 算术运算出错, 如除数为 0 或溢出
        * `SIGILL`: 非法函数映象, 如非法指令
        * `SIGINT`: 用于交互式目的信号, 如中断信号, 如 ctrl-C
        * `SIGSEGV`: 非法访问存储器, 如访问不存在的内存单元
        * `SIGTERM`: 发送给本程序的终止请求信号
* 库函数
    * `void (*signal(int sig, void (*handler)(int)))(int)`: 设置一个函数来处理信号, 即信号处理程序
        * 如果 `handler` 是 `SIG_DFL`, 使用默认的信号处理程序
        * 如果 `handler` 是 `SIG_IGN`, 忽视信号
        * 否则, 调用 `handler` 指向的函数
    * `int raise(int sig)`: 生成信号

## 2.12. <stdarg.h>
* 为可变参数的函数提供支持
* 库变量
    * `va_list`: 用于 `va_start()`, `va_arg()` 和 `va_end()` 这三个宏存储信息的类型
* 库宏
    * `void va_start(va_list ap, last_arg)`: 初始化 `ap` 变量, 与 `va_arg` 和 `va_end` 宏是一起使用的, `last_arg` 是最后一个传递给函数的已知的固定参数, 即省略号之前的参数
    * `type va_arg(va_list ap, type)`: 检索函数参数列表中类型为 `type` 的下一个参数
    * `void va_end(va_list ap)`: 允许使用了 `va_start` 宏的带有可变参数的函数返回, 如果在从函数返回之前没有调用 `va_end`, 则结果为未定义

## 2.13. <stddef.h>
* 定义了各种变量类型和宏, 这些定义中的大部分也出现在其它头文件中
* 库变量
    * `ptrdiff_t`: 有符号整数类型, 是两个指针相减的结果
    * `size_t`: 无符号整数类型, 是 `sizeof` 关键字的结果
    * `wchar_t`: 一个宽字符常量大小的整数类型
* 库宏
    * `NULL`: 空指针常量的值
    * `offsetof(type, member-designator)`: 生成一个类型为 `size_t` 的整型常量, 它是一个结构成员相对于结构开头的字节偏移量, 成员是由 member-designator 给定的, 结构的名称是在 `type` 中给定的

## 2.14. <stdint.h>
> C99 标准, 并非所有编译器都支持
* 定义了一些固定宽度的整数类型别名
* 宽度完全确定的整数
    * `int8_t`, `int16_t`, `int32_t`, `int64_t`
    * `uint8_t`, `uint16_t`, `uint32_t`, `uint64_t`
    * `intptr_t`, `uintptr_t`
* 宽度不小于某个大小的整数, 如 `int_least8_t`
* 宽度不小于某个大小、并且处理速度尽可能快的整数, 如: `int_fast64_t`
* 当前系统可用的最大宽度整数: `intmax_t` 和 `uintmax_t`
* 各种数据类型的极值
    * `INT[8|16|32|64]_MAX` `INT[8|16|32|64]_MIN` `UINT[8|16|32|64]_MAX`
    * `INT_LEAST[8|16|32|64]_MAX` `INT_LEAST[8|16|32|64]_MIN` `UINT_LEAST[8|16|32|64]_MAX`
    * `INT_FAST[8|16|32|64]_MAX` `INT_FAST[8|16|32|64]_MIN` `UINT_FAST[8|16|32|64]_MAX`
    * `INTPTR_MIN` `INTPTR_MAX` `UINTPTR_MAX`
    * `INTMAX_MAX` `INTMAX_MIN` `UINTMAX_MAX`
    * `PTRDIFF_MIN` `PTRDIFF_MAX`
    * `SIZE_MAX`
    * `WCHAR_MIN` `WCHAR_MAX`
* 宏, 可以生成固定宽度的整数常量
    * `INT8_C(x)` `UINT8_C(x)`
    * `INT16_C(x)` `UINT16_C(x)`
    * `INT32_C(x)` `UINT32_C(x)`
    * `INT64_C(x)` `UINT64_C(x)`
    * `INTMAX_C(x)` `UINTMAX_C(x)`

    示例
    ```c++
    uint16_t x = UINT16_C(12);
    intmax_t y = INTMAX_C(3490);
    ```

## 2.15. <stdio.h>
* 标准输入和输出、文件操作相关的库
* 库变量
    * `size_t`: 无符号整数类型, 是 `sizeof` 关键字的结果
    * `FILE`: 存储文件流信息的对象类型
    * `fpos_t`: 存储文件中任何位置的对象类型
* 库宏
    * `NULL`: 空指针常量
    * `stderr`, `stdin`, `stdout`: 是指向 FILE 类型的指针, 分别对应于标准错误、标准输入和标准输出流
    * `_IOFBF、_IOLBF 和 _IONBF`: 扩展了带有特定值的整型常量表达式, 并适用于 setvbuf 函数的第三个参数
    * `BUFSIZ`: 该整数代表了 `setbuf` 函数使用的缓冲区大小
    * `EOF`: 表示已经到达文件结束的负整数
    * `FOPEN_MAX`: 该整数代表了系统可以同时打开的文件数量
    * `FILENAME_MAX`: 该整数代表了字符数组可以存储的文件名的最大长度, 如果实现没有任何限制, 则该值应为推荐的最大值
    * `SEEK_SET`, `SEEK_CUR`, `SEEK_END`: 在 `fseek` 函数中使用, 用于在一个文件中定位不同的位置
    * `L_tmpnam`: 该整数代表了字符数组可以存储的由 tmpnam 函数创建的临时文件名的最大长度
    * `TMP_MAX`: 是 tmpnam 函数可生成的独特文件名的最大数量
* 库函数
    * 标准I/O
        * `int getchar(void)`: 从 `stdin` 获取一个字符 (无符号)
        * `char *gets(char *str)`: 从 `stdin` 读取一行并存到 *str* 中, 当读取到换行符或文件尾时停止
        * `int scanf(const char *format, ...)`: 从 `stdin` 读取格式化输入
            <br/>
        * `int putchar(int char)`: 把参数 *char* 指定的字符 (无符号) 写到 `stdout` 中
        * `int puts(const char *str)`: 把一个字符串写到 `stdout`, 换行符会被追加到输出中
        * `int printf(const char *format, ...)`: 发送格式化输出到 `stdout`
        <!-- * `int vprintf(const char *format, va_list arg)`: 等效于 `int printf(const char *format, ...)` -->
    * 标准错误
        * `void perror(const char *str)`: 把一个描述性错误消息输出到 `stderr`, 格式:  首先输出字符串 str, 后跟一个冒号, 然后是一个空格
    * 字符串
        * `int sscanf(const char *str, const char *format, ...)`: 从字符串读取格式化输入
            <br/>
        * `int sprintf(char *str, const char *format, ...)`: 发送格式化输出到字符串
        <!-- * `int vsprintf(char *str, const char *format, va_list arg)`: 等效于 `int sprintf(char *str, const char *format, ...)` -->
        * `int snprintf(char *str, size_t size, const char *format, ...)`: 格式字符串到字符串中
    * 文件操作
        * `FILE *fopen(const char *filename, const char *mode)`: 打开文件
        * `FILE *freopen(const char *filename, const char *mode, FILE *stream)`: 把一个新的文件与给定的打开的 stream 关联, 同时关闭 stream 中的旧文件
        * `int fflush(FILE *stream)`: 刷新 stream 的输出缓冲区
        * `int fclose(FILE *stream)`: 关闭 stream, 刷新所有的缓冲区
            <br/>
        * `void setbuf(FILE *stream, char *buffer)`: 设置 stream 缓冲
        * `int setvbuf(FILE *stream, char *buffer, int mode, size_t size)`: 设置 stream 缓冲
            <br/>
        * `int fscanf(FILE *stream, const char *format, ...)`: 从 stream 读取格式化输入
        * `int getc(FILE *stream)`: 从 stream 获取下一个字符 (无符号), 并把位置标识符往前移动
        * `int fgetc(FILE *stream)`: 从 stream 获取下一个字符 (无符号), 并把位置标识符往前移动
        * `int ungetc(int char, FILE *stream)`: 把字符 char (无符号) 推入 stream, 以便它是下一个被读取到的字符
        * `char *fgets(char *str, int n, FILE *stream)`: 从 stream 读取一行并存到 *str*, 当读取 (n-1) 个字符、或者换行符、或者文件尾时停止
        * `size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream)`: 从 stream 读取数据到 *ptr* 所指向的数组中
            <br/>
        * `int fprintf(FILE *stream, const char *format, ...)`: 发送格式化输出到 stream 中
        * `int putc(int char, FILE *stream)`: 把参数 char 指定的字符 (无符号) 写入 stream, 并把位置标识符往前移动
        * `int fputc(int char, FILE *stream)`: 把参数 char 指定的字符 (无符号) 写入 stream, 并把位置标识符往前移动
        * `int fputs(const char *str, FILE *stream)`: 把字符串写入到 stream 中
        <!-- * `int vfprintf(FILE *stream, const char *format, va_list arg)`: 使用参数列表发送格式化输出到stream 中 -->
        * `size_t fwrite(const void *ptr, size_t size, size_t nmemb, FILE *stream)`: 把 *ptr* 所指向的数组中的数据写入到 stream
            <br/>
        * `long int ftell(FILE *stream)`: 获取 stream 的当前文件位置
        * `int fgetpos(FILE *stream, fpos_t *pos)`: 获取 stream 的当前文件位置, 并写入到 *pos*
        * `int feof(FILE *stream)`: 是否为 stream 的文件结束标识符
            <br/>
        * `int fseek(FILE *stream, long int offset, int whence)`: 设置 stream 的文件位置: *whence* 指定偏移位置 (可使用宏 `SEEK_SET`, `SEEK_CUR`, `SEEK_END`), *offset* 指定偏移量
        * `void rewind(FILE *stream)`: 设置文件位置为 stream 的开头
        * `int fsetpos(FILE *stream, const fpos_t *pos)`: 设置 stream 的文件位置为给定的位置
            <br/>
        * `int ferror(FILE *stream)`: 获取 stream 的错误标识符
        * `void clearerr(FILE *stream)`: 清除 stream 的文件结束和错误标识符
    * 文件管理
        * `int remove(const char *filename)`: 删除文件
        * `int rename(const char *old_filename, const char *new_filename)`: 重命名文件
    * 临时文件
        * `FILE *tmpfile(void)`: 以二进制更新模式 (`wb+`) 创建临时文件
        * `char *tmpnam(char *str)`: 生成并返回一个有效的临时文件名, 该文件名之前是不存在的

## 2.16. <stdlib.h>
* 定义了各种通用工具
* 库变量
    * `size_t`: 无符号整数类型, 它是 `sizeof` 关键字的结果
    * `wchar_t`: 宽字符常量大小的整数类型
    * `div_t`: `div` 函数返回的结构
    * `ldiv_t`: `ldiv` 函数返回的结构
* 库宏
    * `NULL`: 空指针常量的值
    * `EXIT_FAILURE`: `exit` 函数失败时要返回的值
    * `EXIT_SUCCESS`: `exit` 函数成功时要返回的值
    * `RAND_MAX`: `rand` 函数返回的最大值
    * `MB_CUR_MAX`: 表示在多字节字符集中的最大字符数, 不能大于 `MB_LEN_MAX`
* 库函数
    * 数值转换
        * `int atoi(const char *str)`: 字符串转换为 `int`
        * `long int atol(const char *str)`: 字符串转换为 `long`
        * `double atof(const char *str)`: 字符串转换为 `double`
            <br/>
        * `long int strtol(const char *str, char **endptr, int base)`: 字符串转换为 `long`
        * `unsigned long int strtoul(const char *str, char **endptr, int base)`: 字符串转换为 `unsigned long`
        * `double strtod(const char *str, char **endptr)`: 字符串转换为 `double`
    * 动态内存分配
        * `void *calloc(size_t nitems, size_t size)`: 申请动态内存, 并返回一个指向它的指针
        * `void free(void *ptr)`: 释放动态内存
        * `void *malloc(size_t size)`: 申请动态内存, 并返回一个指向它的指针
        * `void *realloc(void *ptr, size_t size)`: 重新调整之前申请的动态内存的大小
    * 进程管理
        * `void abort(void)`: 使程序异常终止
        * `void exit(int status)`: 使程序正常终止
        * `int atexit(void (*func)(void))`: 当程序正常终止时, 调用指定的函数 *func*
    * OS 相关
        * `char *getenv(const char *name)`: 获取 name 对应的环境字符串
        * `int system(const char *string)`: 使用 OS 的终端执行指定命令 *string*
    * 查找
        * `void *bsearch(const void *key, const void *base, size_t nitems, size_t size, int (*compar)(const void *, const void *))`: 执行二分查找
        * `void qsort(void *base, size_t nitems, size_t size, int (*compar)(const void *, const void*))`: 数组排序
    * 数学
        * `int abs(int x)`: 返回 x 的绝对值
        * `long int labs(long int x)`: 返回 x 的绝对值
            <br/>
        * `div_t div(int numer, int denom)`: 分子除以分母
        * `ldiv_t ldiv(long int numer, long int denom)`: 分子除以分母
            <br/>
        * `int rand(void)`: 返回一个范围在 0 到 RAND_MAX 之间的伪随机数
        * `void srand(unsigned int seed)`: 该函数播种由函数 rand 使用的随机数发生器
    * 多字节字符
        * `int mblen(const char *str, size_t n)`: 返回多字节字符的长度
        * `size_t mbstowcs(schar_t *pwcs, const char *str, size_t n)`: 把多字节字符的字符串转换为数组
        * `int mbtowc(whcar_t *pwc, const char *str, size_t n)`: 检查多字节字符
        * `size_t wcstombs(char *str, const wchar_t *pwcs, size_t n)`: 把数组转换为多字节字符
        * `int wctomb(char *str, wchar_t wchar)`: 检查多字节字符的编码

## 2.17. <string.h>
* 提供了操作字符数组的工具
* 库变量
    * `size_t`: 无符号整数类型, 它是 `sizeof` 关键字的结果
* 库宏
    * `NULL`: 空指针常量的值
* 库函数
    * 内存操作
        * `void *memchr(const void *str, int c, size_t n)`: 在字符串 *str* 的前 n 个字节中搜索第一次出现字符(无符号) c 的位置
            <br/>
        * `int memcmp(const void *str1, const void *str2, size_t n)`: 比较 str1 和 str2 的前 n 个字节
            <br/>
        * `void *memcpy(void *dest, const void *src, size_t n)`: 从 src 复制 n 个字符到 dest
        * `void *memmove(void *dest, const void *src, size_t n)`: 从 src 复制 n 个字符到 dest
        * `void *memset(void *str, int c, size_t n)`: 复制字符 (无符号) c 到字符串 str 的前 n 个字符
    * 字符串操作
        * `char *strcpy(char *dest, const char *src)`: 复制字符串
        * `char *strncpy(char *dest, const char *src, size_t n)`: 复制字符串, 最多复制 n 个字符
            <br/>
        * `char *strcat(char *dest, const char *src)`: 追加字符串
        * `char *strncat(char *dest, const char *src, size_t n)`: 复制字符串, 最多追加 n 个字符
        * `char *strtok(char *str, const char *delim)`: 分解字符串, 以 *delim* 为分隔符
            <br/>
        * `int strcmp(const char *str1, const char *str2)`: 比较字符串
        * `int strncmp(const char *str1, const char *str2, size_t n)`: 比较字符串, 最多比较前 n 个字节
        * `int strcoll(const char *str1, const char *str2)`: 比较字符串, 结果取决于 LC_COLLATE 的位置设置
            <br/>
        * `char *strchr(const char *str, int c)`: 在字符串 *str* 中搜索第一次出现字符(无符号) c 的位置
        * `char *strrchr(const char *str, int c)`: 在字符串 *str* 中搜索最后一次出现字符(无符号) c 的位置
        * `char *strstr(const char *haystack, const char *needle)`: 在字符串 *haystack* 中查找第一次出现字符串 *needle* 的位置
        * `size_t strcspn(const char *str1, const char *str2)`: 检索字符串 str1 开头连续有几个字符都不含字符串 str2 中的字符
        * `size_t strspn(const char *str1, const char *str2)`: 检索字符串 str1 中第一个不在字符串 str2 中出现的字符下标
        * `char *strpbrk(const char *str1, const char *str2)`: 检索字符串 str1 中第一个匹配字符串 str2 中字符的字符, 不包含空结束字符。也就是说, 依次检验字符串 str1 中的字符, 当被检验字符在字符串 str2 中也包含时, 则停止检验, 并返回该字符位置
            <br/>
        * `size_t strlen(const char *str)`: 计算字符串 *str* 的长度
            <br/>
        * `char *strerror(int errnum)`: 从内部数组中搜索错误号 *errnum*, 并返回一个指向错误消息字符串的指针
            <br/>
        * `size_t strxfrm(char *dest, const char *src, size_t n)`: 根据程序当前的区域选项中的 LC_COLLATE 来转换字符串

## 2.18. <time.h>
* 提供了各种操作日期和时间的工具
* 库变量
    * `size_t`: 无符号整数类型, 它是 `sizeof` 关键字的结果
    * `clock_t`: 存储处理器时间的类型 (内部使用 `long` 类型)
    * `time_t is`: 存储日历时间类型 (内部使用 `long long` 类型)
    * `struct tm`: 存储时间和日期的结构
        ```c++
        struct tm {
            int tm_sec;     // 秒, 范围从 0 到 59
            int tm_min;     // 分, 范围从 0 到 59
            int tm_hour;    // 小时, 范围从 0 到 23
            int tm_mday;    // 一月中的第几天, 范围从 1 到 31
            int tm_mon;     // 月, 范围从 0 到 11
            int tm_year;    // 自 1900 年起的年数
            int tm_wday;    // 一周中的第几天, 范围从 0 到 6
            int tm_yday;    // 一年中的第几天, 范围从 0 到 365
            int tm_isdst;   // 夏令时
        };
        ```
* 库宏
    * `NULL`: 空指针常量的值
    * `CLOCKS_PER_SEC`: 每秒的处理器时钟个数
* 库函数
    * `clock_t clock(void)`: 返回程序执行起 (一般为程序的开头), 处理器时钟所使用的时间
    * `time_t time(time_t *timer)`: 获取当前时间, 并把它编码成 `time_t` 格式
    * `double difftime(time_t time1, time_t time2)`: 返回时间差 (单位: 秒) (time1 - time2)
            <br/>
    * `time_t mktime(struct tm *timeptr)`: 把 `tm` 时间格式转换为一个依据本地时区的 `time_t` 时间格式
    * `struct tm *gmtime(const time_t *timer)`: `time_t` 时间格式转换为 `tm` 时间格式, 用协调世界时 (UTC) 也被称为格林尼治标准时间 (GMT) 表示
    * `struct tm *localtime(const time_t *timer)`: `time_t` 时间格式转换为 `tm` 时间格式, 用本地时区表示
            <br/>
    * `char *ctime(const time_t *timer)`: 把 `time_t` 时间格式转换为字符串
    * `char *asctime(const struct tm *timeptr)`: 把 `tm` 时间格式转换为字符串
    * `size_t strftime(char *str, size_t maxsize, const char *format, const struct tm *timeptr)`: 根据 format 中定义的格式化规则, 格式化结构 timeptr 表示的时间, 并把它存储在 str 中
        * format 格式
            | 字符  | 描述                                                |
            | :---: | :-------------------------------------------------- |
            | %a/A  | 星期几的简写/全称                                   |
            | %b/B  | 月份的简写/全称                                     |
            |  %c   | 标准的日期的时间串                                  |
            |  %C   | 年份的后两位数字                                    |
            |  %d   | 十进制表示的每月的第几天                            |
            |  %D   | 月/天/年                                            |
            |  %e   | 在两字符域中, 十进制表示的每月的第几天              |
            |  %F   | 年-月-日                                            |
            |  %g   | 年份的后两位数字, 使用基于周的年                    |
            |  %G   | 年份, 使用基于周的年                                |
            |  %h   | 简写的月份名                                        |
            |  %H   | 24小时制的小时                                      |
            |  %I   | 12小时制的小时                                      |
            |  %j   | 十进制表示的每年的第几天                            |
            |  %m   | 十进制表示的月份                                    |
            |  %M   | 十时制表示的分钟数                                  |
            |  %n   | 新行符                                              |
            |  %p   | 本地的AM或PM的等价显示                              |
            |  %r   | 12小时的时间                                        |
            |  %R   | 显示小时和分钟: hh:mm                               |
            |  %S   | 十进制的秒数                                        |
            |  %t   | 水平制表符                                          |
            |  %T   | 显示时分秒: hh:mm:ss                                |
            |  %u   | 每周的第几天, 星期一为第一天  (值从0到6, 星期一为0) |
            |  %U   | 第年的第几周, 把星期日做为第一天 (值从0到53)        |
            |  %V   | 每年的第几周, 使用基于周的年                        |
            |  %w   | 十进制表示的星期几 (值从0到6, 星期天为0)            |
            |  %W   | 每年的第几周, 把星期一做为第一天 (值从0到53)        |
            |  %x   | 标准的日期串                                        |
            |  %X   | 标准的时间串                                        |
            |  %y   | 不带世纪的十进制年份 (值从0到99)                    |
            |  %Y   | 带世纪部分的十进制年份                              |
            | %z/Z  | 时区名称, 如果不能得到时区名称则返回空字符          |
            |  %%   | 百分号                                              |

* 计算程序运行时间
    ```c++
    time_t begin = time(NULL);
    // ... 执行某些操作

    time_t end = time(NULL);
    printf("%d\n", end - begin);
    ```

## 2.19. <wchar.h>
> C99 标准, 并非所有编译器都支持
* 定义了许多宽字符专用的处理函数

## 2.20. <wctype.h>
> C99 标准, 并非所有编译器都支持
* <ctype.h> 里面函数的宽字符版本